##Redis初步认识
>高性能键值对存储系统，
In-Memorry，数据持久化，重启后加载
支持list set sorted set hash等数据结构
支持Master/Slave(Master作为任务调度者，给多个Slave分配计算任务（Map），最后由Master汇集结果（Reduce))的数据备份

>性能极高，支持多种数据类型

>所有操作都是原子性，支持几个操作合并后的原子性执行


##Redis内存管理
###内存调优
>使用redisObject来管理一个key-value

>VM选项 尽量关闭VM选项，虚拟内存本身用于超出物理内存的数据在内存与磁盘换入换出的一个持久化策略，但是这种内存管理成本很高

>Maxmemory 超过一定的物理内存后拒绝后续的写入请求，可以保持一定量的数据缓存，保护radis的性能和崩溃

>Redis Hash是ridis中HashMap的封装 如果HashMap成员数较小，采用线性的紧凑格式(我的理解是连续的一维存储)来存储该HashMap，省去大量指针的内存开销，默认超过64个成员自动转化成HashMap。主要是查找成本的考虑，成员较小时两者查找速度差异不大，成员较多时，hashmap速度明显占优。
>


###内存淘汰策略
>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。
>
>allkeys-lru：在主键空间中，优先移除最近未使用的key。
>
>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。
>
>allkeys-random：在主键空间中，随机移除某个key。
>
>volatile-random：在设置了过期时间的键空间中，随机移除某个key。
>
>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除
>

###持久化
>默认采用RDB方式: 将内存中数据以快照的方式写入到二进制文件中，可配置自动化的快照方式，这种方式不能保证数据的可靠性，因为快照中保存的数据不是全新的，从快照生成到Redis停机这段时间的数据会丢失，如果对数据的准确性要求高的话，需要采用aof持久化机制。
>
>AOF方式：在这种方式下，redis会将所有的写命令写入到二进制文件中，当redis重启的时候会通过重新执行文件中保存的写命令来复建重启前的整个数据库的内容，
>

###线程体系
>在处理客户端的读写请求处理时，是基于单线程模型的，由一个主线程串行执行，所以多个客户端对同一个键进行操作不会有并发问题，除了客户端请求例如数据的持久化这些操作是在fork的子进程进行操作。
>

###事务实现
>radis事务与常见的关系型数据库有很大的差别，如事务不支持回滚，事务执行时会阻塞其他客户端的请求执行
>

###缓存时效机制
>延迟时效机制: 当客户端请求操作某个key的时候，redis会对客户端请求操作的key进行有效期检查，如果key过期才进行相应的处理
>主动时效机制: 服务端定时去检查失效的缓存，如果失效则进行相应的操作