####Android开发从小工到专家 读书笔记
- 线程池的使用准则
  
  ①不要对同步等待其他任务结果的任务排队，这可能会导致死锁，在死锁中所有现场都被一些任务占用，这些任务依次等待排队任务的结果，而这些任务又无法执行，因为所有的任务都在忙碌的状态
  
  ②有效调整线程池大小，理解排队的任务时CPU限制还是IO限制，如果有不同的任务类，而这些任务类有不同的特征吗，为他们设置不同的任务队列会更有意义，并且可以相应调整每个池
  
  ③调整线程池的大小基本就是避免两类错误，一类是线程太少或者线程太多，对大多数应用程序来说，太多和太少之间的余地相当宽，在运行具有N个处理器的机器上的计算受限制的应用程序中，在线程数目接近N时添加额外的线程可能会改善总的处理能力，而在线程数目超过N时添加额外的线程将不起多用，太多的线程甚至会降低性能，因为会导致额外的环境切换开销。线程池的最佳大小取决于可用处理器的数目以及工作队列中的任务的性质，若在一个具有N个处理器的系统上只有一个工作队列，其中全部是计算性质的任务，在线程池具有N或N+1个线程时一般会获得最大的CPU利用率。对于那些IO限制的任务，需要让线程池的大小超过可用处理器的数目，因为并不是所有线程都一直在工作
  
- SQLite优点
  
  ①零配置，无需安装和配置
  ②存储在单一磁盘文件中的一个完整数据库
  ③支持数据库大小至2TB
  ④数据库文件可以在不同字节顺序的机器之间自由共享
  ⑤足够小，全部源代码大致3万行
  ⑥比目前流行的大多数数据库对数据的操作要快
 
 
- SQLite中的数据事务

  使用事务的两大好处是原子提交和更优性能。SQLite默认会为每个插入，更新操作创建一个事务，并且在每次插入，更新后立即提交。如果连续插入1000次数据，实际的执行过程是重复1000次：创建事务-执行语句-提交。如果使用数据库的事务，那么这个过程会优化为：创建事务-执行1000条语句-提交，这样创建事务和提交这个过程制作一次，通过这种一次性事务可以使性能大幅提升。尤其当数据库位于SD卡时，时间上能节省两个数量级。
  
- APP常见优化
	
  主题切换：将SplashActivity设置成自定义图片背景的主题，然后在Oncreate的super.OnCreate之前切换成正常的主题。这种方式其实并没有真正的加速启动过程，而是通过交互体验来优化了展示的效果。可以解决冷启动白屏黑屏问题

   轻化初始：①异步初始化
②如果所有初始化放在异步，有可能出现异步初始化未完成主线程就要使用的错误，这种情况可以延迟到使用前再初始化
③线程池，ImageLoader，Rxjava在Application初始化，
④可以分时间段初始化
④在SplashActivity中初始化；

   延迟加载 :
ViewStub
懒加载

   Foreach遍历

   Service开启子线程处理或者使用IntentService，不要贪婪地使一个Service持续保留，不仅使得APP因RAM的限制而性能糟糕，而且用户会发现这些常住后台行为的应用并且卸载他。

   当UI隐藏时释放内存
除非接收到onTrimMemory的回调，否则不应该释放UI资源，这确保了用户从其他Activity切换回来时UI资源仍然可用，并且可以迅速恢复Activity，使用顺序和内存消耗决定lmk的优先级

  避免bitmap的浪费，尤其是bitmap的尺寸会对内存呈现出2次方的增加，因为XY都在增加

  尽量避免使用enums，enums的内存消耗通常是static constants的两倍

  注意代码抽象，抽象能提升代码的灵活性和可维护性，但是会导致显著的内存开销，如果抽象没有显著提升效率，应该尽量避免使用它

  为序列化的数据使用nano protobufs(待调研)

  谨慎使用外部库：不要陷入为了一个或两个功能导入整个library，如果没有一个库与需求相吻合，应该考虑自己去实现。

  使用多进程将APP组件切分，当APP需要在后台运行与前台一样大的任务的时候，可以考虑这个技术，类似音乐播放软件


- 内存泄漏

  内存泄漏分为两类
一般内存泄漏(traditional memory leak)的原因是：由忘记释放分配的内存导致的。（译者注：Cursor忘记关闭等）
逻辑内存泄漏(logical memory leak)的原因是：当应用不再需要这个对象，当仍未释放该对象的所有引用。

  ①Static Activities
 
  ②Static Views
 
  如果一个View初始化耗费大量资源，而且在一个Activity生命周期内保持不变，那可以把它变成static，加载到视图树上(View Hierachy)，最后这个static view置null即可

 ③Inner Classes

 如果activity有一个非静态内部类innerclass，非静态内部类会持有外部类的强引用，
如果持有内部类的静态引用，则内存泄漏
 
 ④Anonymous Classes

 匿名内部类也持有外部类的引用，比如当你在Activity中定义了匿名的AsyncTsk，被AsyncTsk持有的Activity直到异步任务结束才会被回收这种很赞很偷懒的写法容易导致泄漏。正如使用内部类一样，只要不跨越生命周期，内部类是完全没问题的。但是，这些类是用于产生后台线程的，这些Java线程是全局的，而且持有创建者的引用（即匿名类的引用），而匿名类又持有外部类的引用。线程是可能长时间运行的，所以一直持有Activity的引用导致当销毁时无法回收。

 这次我们不能通过移除静态成员变量解决，因为线程是于应用生命周期相关的。为了避免泄漏，我们必须舍弃简洁偷懒的写法，把子类声明为静态内部类。

 ⑤Handler同上

 ⑥Threads

 只要是匿名类的实例，不管是不是在工作线程，都会持有Activity的引用，导致内存泄漏。
 
 ⑦Sensor Manager

 如果需要使用这些服务，可以注册监听器，这会导致服务持有了Context的引用，如果在Activity销毁的时候没有注销这些监听器，会导致内存泄漏。
  
-  测试的边界条件：
  
  一致性，有序性，区间性，依赖性，存在性，基数性，时间性(具体翻到P275)
  
- 常见的重构手法
  
  ①提取子函数
  
  ②上移函数到父类

  ③下移函数到子类
  
  ④封装固定的调用逻辑
  
  ⑤使用泛型去除重复逻辑
  
  ⑥使用对象避免过多的参数
  
  ⑦转移函数(重构的支柱)
  
    转移函数是将一个函数从一个类移动到另一个类中，他是重构理论的支柱。如果一个类中有太多行为（即函数），或一个雷雨另一个类之间有太多的函数调用导致搞耦合，可以考虑转移该函数到更适合的类中，通过这种手段可以使每个类更简单，保持系统清晰
   
  ⑧将类型码转为状态模式
  
  ⑨分解胖类
   
 